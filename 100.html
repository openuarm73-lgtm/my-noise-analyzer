<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>ëª¨ë°”ì¼ ì†Œë¦¬ ë¶„ì„ê¸°</title>

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
    background:#0a0a14;color:#eee;
    padding:12px;
  }
  .container{
    max-width:1000px;margin:0 auto;background:#141622;
    border-radius:14px;padding:14px;box-shadow:0 0 20px rgba(0,0,0,0.4)
  }
  h1{text-align:center;font-size:1.3rem;margin-bottom:14px;color:#fff}

  /* PC = 2ì—´ / ëª¨ë°”ì¼ = 1ì—´ */
  .grid{
    display:grid;grid-template-columns:1fr 1fr;gap:14px;
  }
  @media(max-width:850px){
    .grid{grid-template-columns:1fr;}
  }

  .panel{background:#1e2030;padding:14px;border-radius:10px}

  label{display:block;margin-top:10px;font-weight:600;margin-bottom:6px;font-size:0.95rem}

  input,select{
    width:100%;padding:10px;border-radius:10px;border:1px solid #333;
    background:#0f1018;color:#eee;font-size:1rem;
  }

  button{
    width:100%;padding:12px;margin-top:10px;border:none;
    border-radius:10px;background:#3a6df0;color:#fff;
    font-size:1.05rem;font-weight:700;cursor:pointer;
  }
  button:disabled{background:#555}

  .status{
    margin-top:12px;padding:10px;border-radius:8px;font-size:0.9rem;
  }
  .success{background:#1f402f;color:#9ff7c0;}
  .error{background:#402727;color:#ff9d9d;}
  .info{background:#3a3a18;color:#fff7a8;}

  .kpi{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .kpi-item{
    background:#10111a;padding:8px;border-radius:8px;
    box-shadow:0 0 8px rgba(0,0,0,0.4);min-width:110px
  }

  /* ìº”ë²„ìŠ¤ ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
  canvas{
    width:100%;
    border-radius:10px;
    background:#000;
  }
  
  /* ê°œë³„ ìº”ë²„ìŠ¤ ë†’ì´ ì„¤ì • */
  #spectrumCanvas{ height: 250px; cursor: grab; } 
  #timeCanvas{ height: 100px; margin-top: 8px; }
  #spectrogramCanvas{ height: 200px; }

  table{width:100%;border-collapse:collapse;margin-top:10px;font-size:0.9rem}
  th,td{padding:6px;border-bottom:1px solid #333}

  .badge{
    padding:4px 10px;border-radius:999px;color:white;font-weight:700;
  }
  .ok{background:#2fa86d}
  .warn{background:#e49b23}
  .bad{background:#e64545}

  /* ëª¨ë°”ì¼ì—ì„œë„ ì ˆëŒ€ í”ë“¤ë¦¬ì§€ ì•ŠëŠ” AI ë°•ìŠ¤ */
  #aiBox{
    height:120px;overflow:hidden;margin-top:12px;
    background:#11131d;border-radius:10px;padding:10px;
  }
  #aiState{
    height:34px;display:flex;align-items:center;
    overflow:hidden;white-space:nowrap;text-overflow:ellipsis;
    margin-bottom:8px;
  }
  #aiNote{
    height:70px;display:flex;align-items:center;
    overflow:hidden;white-space:nowrap;text-overflow:ellipsis;
    font-size:0.9rem;color:#ddd;
  }

  #tooltip{
    position:absolute;background:rgba(0,0,0,0.8);color:#fff;
    padding:6px;border-radius:6px;font-size:0.85rem;display:none;
    pointer-events:none;z-index:10;
  }

</style>
</head>
<body>

<div class="container">
<h1>ğŸ“± ëª¨ë°”ì¼ ì†Œë¦¬ ë¶„ì„ê¸°</h1>

<div class="grid">

<div class="panel">

  <label>RPM</label>
  <input type="number" id="rpmInput" value="1500">

  <label>ë¸”ë ˆì´ë“œ ìˆ˜ (ê¸°ë³¸ ì£¼íŒŒìˆ˜ ë°°ìˆ˜)</label>
  <input type="number" id="bladeCountInput" value="20">

  <label>ë¶„ì„ ë°°ìˆ˜ (7Ã—/14Ã— í™•ì¥)</label>
  <select id="multipleSelect">
    <option value="7">1~7Ã— (ê¸°ë³¸)</option>
    <option value="14" selected>1~14Ã— (14ë°° íŒì • í¬í•¨)</option>
  </select>

  <label>FFT í¬ê¸°</label>
  <select id="fftSizeSelect">
    <option value="2048">2048</option>
    <option value="4096" selected>4096</option>
    <option value="8192">8192</option>
  </select>

  <label style="margin-top:14px">ì´ë™í‰ê·  ê¸¸ì´</label>
  <input type="number" id="maLen" value="10">

  <label>ê²½ë³´ìŒ</label>
  <select id="alarmMode">
    <option value="off" selected>ë„ê¸°</option>
    <option value="beep" >ë¹„í”„ìŒ</option>
  </select>

  <label>AI dB ì„ê³„ê°’ (ì£¼ì˜/ê²°í•¨)</label>
  <div style="display:flex;gap:8px">
    <input type="number" id="warnThreshold" value="3">
    <input type="number" id="badThreshold" value="8">
  </div>

  <label>RPM ë³€í™” ë¯¼ê°ë„</label>
  <select id="rpmTrendSens">
    <option value="0.01">ë¯¼ê°</option>
    <option value="0.03" selected>ë³´í†µ</option>
    <option value="0.1">ì™„ë§Œ</option>
  </select>
  
  <button id="connectBtn">ğŸ¤ ë§ˆì´í¬ ì—°ê²°</button>
  <button id="startButton" disabled>â–¶ ë¶„ì„ ì‹œì‘</button>
  <button id="stopButton" disabled>â¹ ì¤‘ì§€</button>
  
  <button id="csvApplyBtn" style="background:#555">ğŸ’¾ CSV ì €ì¥ ì ìš© (í•´ì œë¨)</button>
  <div id="status" class="status info">ëŒ€ê¸° ì¤‘â€¦</div>

  <div class="kpi">
    <div class="kpi-item"><div>ì‹œê°„</div><b id="timeCounter">0</b></div>
    <div class="kpi-item"><div>í‰ê· </div><b id="movingAvg">-</b></div>
    <div class="kpi-item"><div>RMS</div><b id="rmsVal">-</b></div>
    <div class="kpi-item"><div>Peak</div><b id="peakVal">-</b></div>
  </div>

  <div class="panel" style="margin-top:12px">
    <div><b>ê¸°ë³¸/ê²°í•¨(7Ã—) ê²°ê³¼</b></div>
    <div id="freqResult" style="margin:6px 0"></div>

    <table>
      <thead><tr><th>ë°°ìˆ˜</th><th>Hz</th><th>Amp</th><th>dB</th></tr></thead>
      <tbody id="harmonicsTable"></tbody>
    </table>

    <div id="aiBox">
      <div id="aiState"><span class="badge ok">-</span></div>
      <div id="aiNote">AI ëŒ€ê¸° ì¤‘â€¦</div>
    </div>
  </div>

</div>

<div class="panel">
  <div style="font-size:0.9rem">ì‹¤ì‹œê°„ FFT ìŠ¤í™íŠ¸ëŸ¼ (í™•ëŒ€/ì´ë™: íœ /ë“œë˜ê·¸)</div>
  <div style="position:relative;margin-top:8px">
    <canvas id="spectrumCanvas" style="cursor: grab;"></canvas>
    <div id="tooltip"></div>
    <div style="font-size:0.8rem; color:#00e0ff; position:absolute; top:2px; left:2px;">ì‹¤ì‹œê°„</div>
    <div style="font-size:0.8rem; color:#ffaa00; position:absolute; top:16px; left:2px;">Peak Hold</div>
    <div style="font-size:0.8rem; color:#44ff44; position:absolute; top:30px; left:2px;">ê¸°ì¤€</div>
  </div>

  <div style="font-size:0.9rem; margin-top: 12px;">ì‹œê°„ íŒŒí˜• (Time Waveform)</div> 
  <canvas id="timeCanvas"></canvas>

  <div style="position:relative;margin-top:0">
    <canvas id="spectrogramCanvas"></canvas>
  </div>
  
  <button id="saveRefBtn" style="background:#8b4513; margin-top: 14px;">ğŸŒŸ ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼ ì €ì¥</button>
  <button id="resetZoomBtn" style="background:#555; margin-top: 6px;">ğŸ” í™•ëŒ€/ì´ë™ ì´ˆê¸°í™”</button>

  <div class="kpi" style="margin-top:12px">
    <div class="kpi-item"><div>Kurtosis</div><b id="kurtVal">-</b></div>
    <div class="kpi-item"><div>Crest</div><b id="crestVal">-</b></div>
    <div class="kpi-item"><div>Bin</div><b id="freqPerBin">-</b></div>
  </div>

</div>

</div>
</div>

<script>
/* =========================================================
   ë§ˆì´í¬, FFT, íŒì • ë¡œì§
   ========================================================= */

let audioContext, analyser, source;
let freqData, timeData;
let isRun=false;
let raf;

let prevDefect=null, prevH14=null, prevRms=null, prevRpm=null;

let csvData = []; 
let isRecording = false; 
let isCsvEnabled = false; 

// ğŸ”¥ [Feature 2] Peak Hold ë°ì´í„°
let peakHoldData = []; 
// ğŸ”¥ [Feature 4] ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„°
let referenceSpectrumData = null;

// ğŸ”¥ [Feature 1] ì¤Œ/íŒ¬ ìƒíƒœ ë³€ìˆ˜
let viewStartIndex = 0;
let viewEndIndex = 0;
let isPanning = false;
let lastPanX = 0;

/* UI GET */
const rpmIn = _id('rpmInput');
const bladeIn = _id('bladeCountInput');
const multIn = _id('multipleSelect');
const fftIn = _id('fftSizeSelect');

const btnMic = _id('connectBtn');
const btnStart = _id('startButton');
const btnStop = _id('stopButton');
const csvApplyBtn = _id('csvApplyBtn'); 
// ğŸ”¥ [Feature 4] ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼ ë²„íŠ¼
const saveRefBtn = _id('saveRefBtn');
// ğŸ”¥ [Feature 1] ì¤Œ ì´ˆê¸°í™” ë²„íŠ¼
const resetZoomBtn = _id('resetZoomBtn');

const statusBox = _id('status');

const maLenIn = _id('maLen');
const warnIn = _id('warnThreshold');
const badIn = _id('badThreshold');
const rpmSensIn = _id('rpmTrendSens');
const alarmIn = _id('alarmMode');

const timeBox = _id('timeCounter');
const avgBox = _id('movingAvg');
const rmsBox = _id('rmsVal');
const peakBox = _id('peakVal');
const kurtBox = _id('kurtVal');
const crestBox = _id('crestVal'); 

const freqRes = _id('freqResult');
const harmTable = _id('harmonicsTable');

const aiState = _id('aiState');
const aiNote  = _id('aiNote');

// ê¸°ì¡´ FFT ìº”ë²„ìŠ¤
const canvas = _id('spectrumCanvas');
const ctx = canvas.getContext('2d');
const tooltip = _id('tooltip');

// ğŸ”¥ [Feature 3] ì‹œê°„ íŒŒí˜• ìº”ë²„ìŠ¤
const timeCanvas = _id('timeCanvas');
const timeCtx = timeCanvas.getContext('2d');

// ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ìº”ë²„ìŠ¤
const specCanvas = _id('spectrogramCanvas');
const specCtx = specCanvas.getContext('2d');

let dbHist=[];

function _id(x){return document.getElementById(x);}

/* ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (ë¶„ì„ ë£¨í”„ ë°–ì—ì„œë§Œ ì‹¤í–‰) */
function setCanvasSize() {
  const containerWidth = canvas.parentNode.clientWidth;
  
  // FFT ìº”ë²„ìŠ¤
  canvas.width = containerWidth;
  // canvas.height = 250; // Height set in CSS
  
  // ğŸ”¥ [Feature 3] ì‹œê°„ íŒŒí˜• ìº”ë²„ìŠ¤
  timeCanvas.width = containerWidth;
  // timeCanvas.height = 100; // Height set in CSS

  // ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ìº”ë²„ìŠ¤
  specCanvas.width = containerWidth;
  // specCanvas.height = 200; // Height set in CSS
}
setCanvasSize();
window.addEventListener('resize', setCanvasSize); 


/* ---------- CSV ì €ì¥ ë¡œì§ (ë³€í™” ì—†ìŒ) ---------- */
function startRecording(){
    if(!isCsvEnabled) return; 
    
    csvData = []; 
    isRecording = true;
    
    const header = ['Time(s)', 'RPM', 'BladeCount', 'BaseHz', 'DefectHz', 'BaseDb', 'DefectDb', 'DiffDb', 'MovingAvg', 'RMS_Db', 'Peak_Db', 'Kurtosis', 'CrestFactor', 'AI_State', 'AI_Note'];
    csvData.push(header);
}
function stopRecording(){
    if(!isCsvEnabled || !isRecording) {
        statusBox.innerText="ì¤‘ì§€ë¨.";
        return;
    }

    isRecording = false;

    if(csvData.length <= 1){
        statusBox.innerText="ì¤‘ì§€ë¨. ì €ì¥í•  ë°ì´í„°ê°€ ì—†ì–´ CSV ë‹¤ìš´ë¡œë“œë¥¼ ê±´ë„ˆí‚µë‹ˆë‹¤.";
        return;
    }

    const csvContent = csvData.map(e => e.join(",")).join("\n");
    const blob = new Blob(["\ufeff", csvContent], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `sound_analysis_${new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-')}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    csvData = []; 
    statusBox.innerText="ì¤‘ì§€ë¨. CSV ë‹¤ìš´ë¡œë“œ ì™„ë£Œ";
}

/* ---------- ë§ˆì´í¬ ì—°ê²° ---------- */
btnMic.onclick = async ()=>{
  try{
    let stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioContext = new (window.AudioContext||window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = Number(fftIn.value);
    // FFT Size ë³€ê²½ ì‹œ ë°ì´í„° ë°°ì—´ ì¬ìƒì„± ë° ì¤Œ ë²”ìœ„ ì´ˆê¸°í™”
    freqData = new Uint8Array(analyser.frequencyBinCount);
    timeData = new Uint8Array(analyser.fftSize);
    
    // ğŸ”¥ [Feature 1] ì¤Œ ë²”ìœ„ ì´ˆê¸°í™”
    viewStartIndex = 0;
    viewEndIndex = analyser.frequencyBinCount;
    // ğŸ”¥ [Feature 2] Peak Hold ì´ˆê¸°í™”
    peakHoldData = new Uint8Array(analyser.frequencyBinCount);
    // ğŸ”¥ [Feature 4] Reference ì´ˆê¸°í™”
    referenceSpectrumData = null;


    source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);

    btnMic.disabled=true; btnMic.innerText="ğŸ¤ ì—°ê²°ë¨";
    btnStart.disabled=false;
    statusBox.className="status success";
    statusBox.innerText="ë§ˆì´í¬ ì—°ê²° ì™„ë£Œ";
  }catch(e){
    statusBox.className="status error";
    statusBox.innerText="ë§ˆì´í¬ ì—°ê²° ì‹¤íŒ¨: "+e;
  }
};

/* ---------- ë¶„ì„ ì‹œì‘ ---------- */
btnStart.onclick = ()=>{
  if(!audioContext) return;
  isRun=true;
  btnStart.disabled=true;
  btnStop.disabled=false;
  
  startRecording(); 
  
  // ğŸ”¥ [Feature 2] ë¶„ì„ ì‹œì‘ ì‹œ Peak Hold ë°ì´í„° ì´ˆê¸°í™”
  if (analyser) {
    peakHoldData = new Uint8Array(analyser.frequencyBinCount);
  }

  if(isCsvEnabled){
      statusBox.className="status info";
      statusBox.innerText="ë¶„ì„ ë° CSV ì €ì¥ ì¤‘â€¦";
  } else {
      statusBox.className="status info";
      statusBox.innerText="ë¶„ì„ ì¤‘â€¦ (CSV ì €ì¥ í•´ì œë¨)";
  }
  
  t0=performance.now();
  
  // ìµœì´ˆ í•œ ë²ˆ ë°°ê²½ ì±„ìš°ê¸°
  specCtx.fillStyle = '#0a0a14'; 
  specCtx.fillRect(0, 0, specCanvas.width, specCanvas.height);
  timeCtx.fillStyle = '#0a0a14';
  timeCtx.fillRect(0, 0, timeCanvas.width, timeCanvas.height);
  
  loop();
};

/* ---------- ì¤‘ì§€ ---------- */
btnStop.onclick = ()=>{
  isRun=false; 
  btnStart.disabled=false; 
  btnStop.disabled=true;
  
  stopRecording(); 
};


/* ---------- CSV ì ìš© ë²„íŠ¼ í† ê¸€ ë¡œì§ (ë³€í™” ì—†ìŒ) ---------- */
csvApplyBtn.onclick = () => {
    if(isRun) {
        statusBox.className = 'status warn';
        statusBox.innerText = 'ë¶„ì„ ì¤‘ì—ëŠ” CSV ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
        return;
    }
    
    isCsvEnabled = !isCsvEnabled; 

    if (isCsvEnabled) {
        csvApplyBtn.style.background = '#3a6df0';
        csvApplyBtn.innerText = 'ğŸ’¾ CSV ì €ì¥ ì ìš© (í™œì„±í™”ë¨)';
        statusBox.className = 'status success';
        statusBox.innerText = 'CSV ì €ì¥ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. "ë¶„ì„ ì‹œì‘" ì‹œ ê¸°ë¡ë©ë‹ˆë‹¤.';
    } else {
        csvApplyBtn.style.background = '#555';
        csvApplyBtn.innerText = 'ğŸ’¾ CSV ì €ì¥ ì ìš© (í•´ì œë¨)';
        statusBox.className = 'status info';
        statusBox.innerText = 'CSV ì €ì¥ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.';
    }
};

// ğŸ”¥ [Feature 4] ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼ ì €ì¥ ë²„íŠ¼ ë¡œì§
saveRefBtn.onclick = () => {
    if (!freqData || !isRun) {
        statusBox.className = 'status warn';
        statusBox.innerText = 'ë¶„ì„ ì‹œì‘ í›„ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
        return;
    }
    // í˜„ì¬ freqData ë°°ì—´ì„ ë³µì‚¬í•˜ì—¬ ê¸°ì¤€ ë°ì´í„°ë¡œ ì €ì¥ (Deep copy)
    referenceSpectrumData = new Uint8Array(freqData); 
    statusBox.className = 'status info';
    statusBox.innerText = 'ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼(ë…¹ìƒ‰)ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.';
};

// ğŸ”¥ [Feature 1] ì¤Œ ì´ˆê¸°í™” ë²„íŠ¼ ë¡œì§
resetZoomBtn.onclick = () => {
    if (analyser) {
        viewStartIndex = 0;
        viewEndIndex = analyser.frequencyBinCount;
        statusBox.className = 'status info';
        statusBox.innerText = 'í™•ëŒ€/ì´ë™ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.';
    }
};


/* ---------- ë¶„ì„ ë£¨í”„ ---------- */
let t0=0;
function loop(){
  if(!isRun) return; 

  analyser.getByteFrequencyData(freqData);
  analyser.getByteTimeDomainData(timeData);
  
  // ğŸ”¥ [Feature 2] Peak Hold ë°ì´í„° ì—…ë°ì´íŠ¸
  if (peakHoldData.length !== freqData.length) {
      peakHoldData = [...freqData];
  } else {
      for (let i = 0; i < freqData.length; i++) {
          if (freqData[i] > peakHoldData[i]) {
              peakHoldData[i] = freqData[i];
          }
      }
  }

  // ... ì´í•˜ ê¸°ì¡´ ë¶„ì„ ë¡œì§ (ë³€í™” ì—†ìŒ)
  let sr = audioContext.sampleRate;
  let fftN = analyser.fftSize;
  let bin = sr/fftN;

  let rpm = Number(rpmIn.value);
  let blade = Number(bladeIn.value);
  let maxMul = Number(multIn.value);

  let base = (rpm/60)*blade;
  let defect = base*7;

  let baseI = Math.round(base/bin);
  let defectI = Math.round(defect/bin);

  let baseAmp = freqData[clamp(baseI)];
  let defAmp  = freqData[clamp(defectI)];

  let baseDb = ampToDb(baseAmp);
  let defDb  = ampToDb(defAmp);

  let diff = Math.abs(defDb-baseDb);

  /* ì´ë™í‰ê·  */
  let ma = Number(maLenIn.value);
  dbHist.push(diff);
  if(dbHist.length>ma) dbHist.shift();
  let avg = dbHist.reduce((a,b)=>a+b,0)/(dbHist.length||1);

  /* RMS, Peak */
  let tArr = floatNorm(timeData);
  let rms = rmsCalc(tArr);
  let rmsDb = 20*Math.log10(rms||1e-8);
  let peak = tArr.reduce((a,b)=>Math.max(a,Math.abs(b)),0);
  let peakDb = 20*Math.log10(peak||1e-8);

  let kurt = kurtCalc(tArr);
  let crest = crestCalc(tArr);

  /* ê³ ì¡°íŒŒ */
  let hList=[];
  for(let k=1;k<=maxMul;k++){
    let f = base*k;
    let idx=Math.round(f/bin);
    let a=freqData[clamp(idx)];
    hList.push({k,f,a,db:ampToDb(a)});
  }

  let h14 = hList.find(h=>h.k===14);

  /* AI íŒì • */
  let aiL="ì •ìƒ", aiC="ok", msg="";

  let warnT=Number(warnIn.value);
  let badT=Number(badIn.value);

  if(diff>badT){ aiL="ê²°í•¨ ì˜ì‹¬"; aiC="bad"; msg=`dBì°¨ì´ ${diff.toFixed(2)}`; }
  else if(diff>warnT){ aiL="ì£¼ì˜"; aiC="warn"; msg=`dBì°¨ì´ ${diff.toFixed(2)}`; }

  /* 14Ã— ìë™ íŒì • */
  if(h14){
    let ratio14 = defAmp>0 ? h14.a/defAmp : 0;

    if(prevDefect && defAmp < prevDefect-4 && ratio14<2){
      aiL="ì •ìƒ(ì••ë ¥ê°ì†ŒíŒ¨í„´)";
      aiC="ok";
      msg="7Ã— ê°ì†Œ & 14/7 ë‚®ìŒ";
    }
    if(prevH14 && (h14.db-prevH14)>6){
      aiL="ê²°í•¨(14Ã— ê¸‰ì¦)";
      aiC="bad";
      msg=`14Ã— +${(h14.db-prevH14).toFixed(2)} dB`;
    }
    if(ratio14>3){
      aiL="ë¹„ì •ìƒ(14Ã— ê³¼ë‹¤)";
      aiC="bad";
      msg=`14/7=${ratio14.toFixed(2)}`;
    }
  }

  /* RPM íŠ¸ë Œë“œ */
  if(prevRpm){
    let sens=Number(rpmSensIn.value);
    let rchg=(rpm-prevRpm)/(prevRpm||1);
    if(Math.abs(rchg)>sens){
      if(rchg>0 && rmsDb>prevRms+0.5){
        msg="RPMâ†‘ â†’ RMSâ†‘ (ì •ìƒ)";
      }
      if(rchg<0 && rmsDb<prevRms-0.5){
        msg="RPMâ†“ â†’ RMSâ†“ (ì •ìƒ)";
      }
    }
  }

  /* AI í‘œì‹œ */
  aiState.innerHTML=`<span class="badge ${aiC}">${aiL}</span>`;
  aiNote.innerText=msg||"";

  /* UI */
  timeBox.innerText = Math.floor((performance.now()-t0)/1000)+"s";
  avgBox.innerText = avg.toFixed(2);
  rmsBox.innerText = rmsDb.toFixed(2)+" dB";
  peakBox.innerText = peakDb.toFixed(2)+" dB";
  kurtBox.innerText = kurt.toFixed(2);
  crestBox.innerText = crest.toFixed(2);
  _id('freqPerBin').innerText = bin.toFixed(2);

  freqRes.innerHTML =
    `ê¸°ë³¸: ${Math.round(base)}Hz / ${baseDb.toFixed(2)}dB<br>`+
    `ê²°í•¨(7Ã—): ${Math.round(defect)}Hz / ${defDb.toFixed(2)}dB<br>`+
    `ì°¨ì´: ${diff.toFixed(2)}dB`;

  harmTable.innerHTML="";
  hList.forEach(h=>{
    harmTable.innerHTML+=`<tr><td>${h.k}Ã—</td><td>${Math.round(h.f)}</td><td>${h.a}</td><td>${h.db.toFixed(2)}</td></tr>`;
  });

  /* CSV ë°ì´í„° ê¸°ë¡ */
  if(isRecording){
      const timeElapsed = (performance.now()-t0)/1000;
      const row = [
          timeElapsed.toFixed(2), 
          rpm, blade, 
          base.toFixed(2), defect.toFixed(2), 
          baseDb.toFixed(2), defDb.toFixed(2), 
          diff.toFixed(2), avg.toFixed(2), 
          rmsDb.toFixed(2), peakDb.toFixed(2), 
          kurt.toFixed(2), crest.toFixed(2),
          aiL, msg
      ];
      csvData.push(row);
  }

  /* ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° */
  drawFFT(freqData);
  drawSpectrogram(freqData);
  drawTimeWaveform(timeData); // ğŸ”¥ [Feature 3] ì‹œê°„ íŒŒí˜• ê·¸ë¦¬ê¸°

  /* prev ì—…ë°ì´íŠ¸ */
  prevDefect = defAmp;
  prevH14 = h14 ? h14.db : null;
  prevRms = rmsDb;
  prevRpm = rpm;

  raf=requestAnimationFrame(loop);
}

/* ì§„í­(0-255)ì„ íˆíŠ¸ë§µ ìƒ‰ìƒìœ¼ë¡œ ë³€í™˜ (ë³€í™” ì—†ìŒ) */
function ampToHeatmap(amplitude) {
    let ratio = amplitude / 255;
    let r, g, b;

    // ë‚®ì€ ì§„í­(íŒŒë‘) -> ì¤‘ê°„ ì§„í­(ë…¸ë‘) -> ë†’ì€ ì§„í­(ë¹¨ê°•)
    if (ratio < 0.5) {
        r = Math.floor(ratio * 2 * 255);
        g = Math.floor(ratio * 2 * 255);
        b = 255;
    } else {
        r = 255;
        g = Math.floor((1 - (ratio - 0.5) * 2) * 255);
        b = 0;
    }
    
    return {r: Math.min(255, r), g: Math.min(255, g), b: Math.min(255, b), a: 255};
}

/* ğŸ”¥ [Feature 3] ì‹œê°„ íŒŒí˜• ê·¸ë¦¬ê¸° */
function drawTimeWaveform(arr) {
    const w = timeCanvas.width;
    const h = timeCanvas.height;
    timeCtx.clearRect(0, 0, w, h);
    timeCtx.fillStyle = "#0a0a14"; // ë°°ê²½ìƒ‰
    timeCtx.fillRect(0, 0, w, h);
    
    // Yì¶• ì¤‘ì•™ì„ 
    timeCtx.beginPath();
    timeCtx.moveTo(0, h / 2);
    timeCtx.lineTo(w, h / 2);
    timeCtx.strokeStyle = "#555";
    timeCtx.lineWidth = 1;
    timeCtx.stroke();
    
    // íŒŒí˜• ê·¸ë¦¬ê¸°
    timeCtx.beginPath();
    timeCtx.strokeStyle = "#4aaaff";
    timeCtx.lineWidth = 2;
    
    const bufferLength = arr.length;
    let x = 0;
    const sliceWidth = w * 1.0 / bufferLength;
    
    for(let i = 0; i < bufferLength; i++) {
        // timeDataëŠ” 0~255 ê°’. 128ì´ 0 ë ˆë²¨. (ê°€ìš´ë° ì •ë ¬)
        const v = arr[i] / 255.0; 
        const y = v * h; 

        if(i === 0) {
            timeCtx.moveTo(x, y);
        } else {
            timeCtx.lineTo(x, y);
        }

        x += sliceWidth;
    }
    timeCtx.stroke();
}


/* ì„¸ë¡œ ìŠ¤í¬ë¡¤ ìŠ¤í™íŠ¸ë¡œê·¸ë¨ (ì¤Œ/íŒ¬ ì ìš©) */
function drawSpectrogram(arr) {
    const specWidth = specCanvas.width;
    const specHeight = specCanvas.height;
    
    // 1. ê¸°ì¡´ ì´ë¯¸ì§€ë¥¼ ì•„ë˜ë¡œ 1í”½ì…€ì”© ì´ë™ (Vertical Scroll: Time axis)
    specCtx.drawImage(specCanvas, 0, 1); 

    // 2. ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ê·¸ë¦´ ê°€ì¥ ìœ„ìª½ í–‰ (y = 0)ì„ ì´ˆê¸°í™”
    const yPos = 0; 
    specCtx.fillStyle = '#0a0a14'; 
    specCtx.fillRect(0, yPos, specWidth, 1); 

    const numBins = arr.length; 
    const startIdx = viewStartIndex; // ğŸ”¥ ì¤Œ ì‹œì‘ ì¸ë±ìŠ¤
    const endIdx = viewEndIndex;     // ğŸ”¥ ì¤Œ ë ì¸ë±ìŠ¤
    const viewRange = endIdx - startIdx;

    // 3. ì£¼íŒŒìˆ˜ ë¹ˆì„ Xì¶•(Frequency)ì— ë§¤í•‘í•˜ì—¬ ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
    for (let x = 0; x < specWidth; x++) { 
        // Xì¶• ë§¤í•‘ (FFT ìŠ¤í™íŠ¸ëŸ¼ê³¼ ì¼ì¹˜)
        // ìº”ë²„ìŠ¤ Xì¢Œí‘œë¥¼ ì¤Œëœ ë²”ìœ„ì˜ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
        const binFraction = (x / specWidth) * viewRange + startIdx; 
        let binIndex = Math.floor(binFraction);
        
        // ì¸ë±ìŠ¤ í´ë¨í•‘
        binIndex = Math.min(numBins - 1, Math.max(0, binIndex));

        const amplitude = arr[binIndex];
        const color = ampToHeatmap(amplitude);
        
        // 4. ìƒˆë¡œìš´ í”½ì…€ì„ ê°€ì¥ ìœ„ìª½ í–‰(y=0)ì— ê·¸ë¦½ë‹ˆë‹¤.
        specCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
        specCtx.fillRect(x, yPos, 1, 1); 
    }
    
    // 5. ìŠ¤í¬ë¡¤ í›„ ê°€ì¥ ì•„ë˜ì— ë‚¨ì€ 1í”½ì…€ í–‰(y=specHeight-1)ì„ í™•ì‹¤í•˜ê²Œ ì§€ì›ë‹ˆë‹¤.
    specCtx.fillStyle = '#0a0a14'; 
    specCtx.fillRect(0, specHeight - 1, specWidth, 1); 
}


/* ---------- FFT ê·¸ë¦¬ê¸° (ì¤Œ/íŒ¬, Peak Hold, ê¸°ì¤€ì„  í¬í•¨) ---------- */
function drawFFT(arr){ 
  let w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000"; ctx.fillRect(0,0,w,h);

  // ğŸ”¥ [Feature 1] ì¤Œ ë²”ìœ„ ì„¤ì •
  const startIdx = viewStartIndex;
  const endIdx = viewEndIndex;
  const viewRange = endIdx - startIdx;

  // ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ ì •ì˜ (ì¬ì‚¬ìš©ì„ ìœ„í•´)
  const drawLine = (data, color, lineWidth) => {
    ctx.beginPath();
    for(let i=startIdx;i<endIdx;i++){
        const x=(i-startIdx)/viewRange*w; // ì¤Œëœ ë²”ìœ„ì— ë§ê²Œ Xì¶• ì •ê·œí™”
        const y=h - (data[i]/255)*h;
        if(i===startIdx) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle=color;
    ctx.lineWidth=lineWidth;
    ctx.stroke();
  };

  // 1. ğŸ”¥ [Feature 4] ê¸°ì¤€ ìŠ¤í™íŠ¸ëŸ¼ (ë…¹ìƒ‰)
  if (referenceSpectrumData) {
      drawLine(referenceSpectrumData, "#44ff44", 1);
  }
  
  // 2. ğŸ”¥ [Feature 2] Peak Hold ìŠ¤í™íŠ¸ëŸ¼ (ì£¼í™©ìƒ‰)
  if (peakHoldData.length > 0) {
      drawLine(peakHoldData, "#ffaa00", 1); 
  }

  // 3. ì‹¤ì‹œê°„ FFT ìŠ¤í™íŠ¸ëŸ¼ (íŒŒë€ìƒ‰)
  drawLine(arr, "#00e0ff", 1.5);
  

  // 4. ê¸°ë³¸ ì£¼íŒŒìˆ˜ ì„ (1x ~ maxMul x) ê·¸ë¦¬ê¸° (ì¤Œ ë²”ìœ„ì— ë§ê²Œ ì¡°ì •)
  if(audioContext && analyser){
    let sr = audioContext.sampleRate;
    let fftN = analyser.fftSize;
    let bin = sr/fftN;
    
    // ì…ë ¥ ê°’ ê°€ì ¸ì˜¤ê¸°
    let rpm = Number(rpmIn.value);
    let blade = Number(bladeCountInput.value);
    let base = (rpm/60)*blade;
    let maxMul = Number(multIn.value); 

    for(let k=1; k <= maxMul; k++){
        let f = base * k;
        let idx = Math.round(f / bin); 
        
        if (idx >= startIdx && idx < endIdx){ // ì¤Œ ë²”ìœ„ ë‚´ì— ìˆì„ ë•Œë§Œ ê·¸ë¦¬ê¸°
            let x = ((idx - startIdx) / viewRange) * w; // ì¤Œ ë²”ìœ„ì— ë§ê²Œ X ì¢Œí‘œ ê³„ì‚°

            // 1x, 7x, 14xëŠ” ë” ì§„í•˜ê²Œ í‘œì‹œ
            if(k === 1 || k === 7 || k === 14){
                ctx.strokeStyle = "#ff4444"; 
                ctx.lineWidth = 2;
            } else {
                ctx.strokeStyle = "rgba(255, 0, 0, 0.7)";
                ctx.lineWidth = 1;
            }

            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
        }
    }
  }
}

/* ---------- Tooltip (ì¤Œ ë²”ìœ„ì— ë§ê²Œ ì¡°ì •) ---------- */
canvas.addEventListener('mousemove',e=>{
  if(!analyser) return;

  let r=canvas.getBoundingClientRect();
  let x=e.clientX-r.left;
  let w=canvas.width;
  
  // ìº”ë²„ìŠ¤ Xì¢Œí‘œë¥¼ ì¤Œ ë²”ìœ„ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
  const startIdx = viewStartIndex;
  const endIdx = viewEndIndex;
  const viewRange = endIdx - startIdx;
  
  let idx = startIdx + Math.floor((x/w)*viewRange);

  idx = clamp(idx); // ìµœì¢… í´ë¨í•‘

  let sr=audioContext.sampleRate;
  let f=idx*(sr/analyser.fftSize);
  let a=freqData[idx];
  tooltip.style.left=x+"px";
  tooltip.style.top="10px";
  tooltip.style.display="block";
  tooltip.textContent=`${Math.round(f)}Hz / ${a}`;
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display="none");


/* ---------- ğŸ”¥ [Feature 1] ì¤Œ/íŒ¬ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---------- */

// ë§ˆìš°ìŠ¤ ë‹¤ìš´: íŒ¨ë‹ ì‹œì‘
canvas.addEventListener('mousedown', (e) => {
    isPanning = true;
    lastPanX = e.clientX;
    canvas.style.cursor = 'grabbing';
});

// ë§ˆìš°ìŠ¤ ì—…: íŒ¨ë‹ ì¢…ë£Œ
document.addEventListener('mouseup', () => {
    if (isPanning) {
        isPanning = false;
        canvas.style.cursor = 'grab';
    }
});

// ë§ˆìš°ìŠ¤ ì´ë™: íŒ¨ë‹ ì²˜ë¦¬
canvas.addEventListener('mousemove', (e) => {
    if (!isPanning || !analyser) return;

    const dx = e.clientX - lastPanX;
    lastPanX = e.clientX;
    
    const binCount = analyser.frequencyBinCount;
    const canvasWidth = canvas.width;
    const currentRange = viewEndIndex - viewStartIndex;
    
    // ìº”ë²„ìŠ¤ ì´ë™ í”½ì…€ì„ ë¹ˆ ì¸ë±ìŠ¤ ë³€í™”ëŸ‰ìœ¼ë¡œ ë³€í™˜
    const binShift = Math.round(dx / canvasWidth * currentRange);
    
    // Pan Logic
    if (binShift !== 0) {
        let newStart = viewStartIndex - binShift;
        let newEnd = viewEndIndex - binShift;
        
        // ê²½ê³„ í´ë¨í•‘
        if (newStart < 0) {
            newEnd += (0 - newStart);
            newStart = 0;
        }
        if (newEnd > binCount) {
            newStart -= (newEnd - binCount);
            newEnd = binCount;
        }
        
        // ìµœì¢… ì ìš©
        viewStartIndex = Math.max(0, newStart);
        viewEndIndex = Math.min(binCount, newEnd);
        
        // ì¦‰ì‹œ ì¬ê·¸ë¦¬ê¸° (ë¶€ë“œëŸ¬ìš´ ìƒí˜¸ì‘ìš©)
        if (isRun) {
             drawFFT(freqData);
             drawSpectrogram(freqData);
        }
    }
});

// ë§ˆìš°ìŠ¤ íœ : ì¤Œ ì²˜ë¦¬
canvas.addEventListener('wheel', (e) => {
    if (!analyser) return;
    
    e.preventDefault();
    
    const binCount = analyser.frequencyBinCount;
    const currentRange = viewEndIndex - viewStartIndex;
    
    // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì¤Œ ì¤‘ì‹¬ ê³„ì‚° (0.0 ~ 1.0)
    const mouseXRatio = (e.clientX - canvas.getBoundingClientRect().left) / canvas.width;
    
    let newRange;

    // Zoom Out (deltaY < 0): ë²”ìœ„ 1.1ë°° í™•ì¥
    if (e.deltaY < 0) {
        newRange = Math.min(binCount, Math.round(currentRange * 1.1));
    } 
    // Zoom In (deltaY > 0): ë²”ìœ„ 1.1ë°° ì¶•ì†Œ
    else { 
        // ìµœì†Œ ì¤Œ ë²”ìœ„ëŠ” ì „ì²´ ëŒ€ì—­ì˜ 5% ë˜ëŠ” 100 ë¹ˆìœ¼ë¡œ ì œí•œ
        const minRange = Math.max(Math.round(binCount * 0.05), 100); 
        newRange = Math.max(minRange, Math.round(currentRange / 1.1)); 
    }
    
    const diffRange = newRange - currentRange;
    
    // ì¤Œ ì¤‘ì‹¬ì„ ìœ ì§€í•˜ë©´ì„œ ì‹œì‘/ë ì¸ë±ìŠ¤ ê³„ì‚°
    let newStart = viewStartIndex - Math.round(diffRange * mouseXRatio);
    let newEnd = viewEndIndex + Math.round(diffRange * (1 - mouseXRatio));

    // ê²½ê³„ í´ë¨í•‘
    if (newStart < 0) {
        newEnd += (0 - newStart);
        newStart = 0;
    }
    if (newEnd > binCount) {
        newStart -= (newEnd - binCount);
        newEnd = binCount;
    }
    
    // ìµœì¢… ì ìš©
    viewStartIndex = Math.max(0, newStart);
    viewEndIndex = Math.min(binCount, newEnd);
    
    // ì¦‰ì‹œ ì¬ê·¸ë¦¬ê¸°
    if (isRun) {
        drawFFT(freqData);
        drawSpectrogram(freqData);
    }
}, {passive: false});


/* ---------- ìœ í‹¸ (ë³€í™” ì—†ìŒ) ---------- */
function clamp(v){return Math.max(0,Math.min(freqData.length-1,v));}
function ampToDb(a){return 20*Math.log10((a||1)/255);}
function floatNorm(u8){return Array.from(u8,x=>(x-128)/128);}
function rmsCalc(arr){return Math.sqrt(arr.reduce((s,x)=>s+x*x,0)/(arr.length||1));}
function kurtCalc(arr){
  let m=arr.reduce((s,x)=>s+x,0)/arr.length;
  let m2=0,m4=0;arr.forEach(x=>{let d=x-m;m2+=d*d;m4+=d*d*d*d;});
  m2/=arr.length; m4/=arr.length; return m4/(m2*m2+1e-12);
}
function crestCalc(arr){
  let p=Math.max(...arr.map(x=>Math.abs(x)));
  let r=rmsCalc(arr);
  return p/(r||1e-8);
}
</script>

</body>
</html>